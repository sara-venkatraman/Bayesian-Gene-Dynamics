beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.2)
profileA <- alphaRatio*profileB + (1-alphaRatio)*beta*hours + rnorm(n, mean=0, sd=1)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,2),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.2[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.2
alphaRatioValues <- seq(from=0, to=1, length.out=5)
betaValues <- seq(from=0, to=0.5, length.out=5)
hours <- seq(0, 36)
n <- length(hours) # Number of samples (time points)
r <- 2 # rank of design matrix
mB <- function(t) { return(sin(t)) }
numSimulations <- 100
coverageProb.2 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.2) <- alphaRatioValues
colnames(coverageProb.2) <- betaValues
par(mfrow=c(5,5), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.2)
profileA <- alphaRatio*profileB + (1-alphaRatio)*beta*hours + rnorm(n, mean=0, sd=1)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,2),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.2[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.2
alphaRatioValues <- seq(from=0, to=1, length.out=5)
betaValues <- seq(from=0, to=0.5, length.out=5)
hours <- seq(0, 36)
n <- length(hours) # Number of samples (time points)
r <- 2 # rank of design matrix
mB <- function(t) { return(sin(t)) }
numSimulations <- 100
coverageProb.2 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.2) <- alphaRatioValues
colnames(coverageProb.2) <- betaValues
par(mfrow=c(5,5), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.2)
profileA <- alphaRatio*profileB + (1-alphaRatio)*beta*hours + rnorm(n, mean=0, sd=1)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,3.5),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.2[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.2
alphaRatioValues <- seq(from=0, to=1, length.out=5)
betaValues <- seq(from=0, to=0.4, length.out=5)
hours <- seq(0, 36)
n <- length(hours) # Number of samples (time points)
r <- 2 # rank of design matrix
mB <- function(t) { return(sin(t)) }
numSimulations <- 100
coverageProb.2 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.2) <- alphaRatioValues
colnames(coverageProb.2) <- betaValues
par(mfrow=c(5,5), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.3)
profileA <- alphaRatio*profileB + (1-alphaRatio)*beta*hours + rnorm(n, mean=0, sd=1)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,3.5),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.2[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.2
alphaRatioValues <- seq(from=0, to=1, length.out=6)
betaValues <- seq(from=0, to=0.3, length.out=6)
hours <- seq(0.01, 36)
n <- length(hours) # Number of samples (time points)
r <- 4 # rank of design matrix
mA <- function(t) { return(sin(t)) }#return(sin(0.5*t)/(0.5*t)) }
mB <- function(t) { return(exp(-t)) }
mAIntegrals <- rep(0,n);  mBIntegrals <- rep(0,n)
for(i in 1:n) {
mAIntegrals[i] <- integrate(mA, lower=0, upper=hours[i])$value
mBIntegrals[i] <- integrate(mB, lower=0, upper=hours[i])$value
}
# Can adjust this parameter (mRNA degradation rate)
kA <- 0.2;  kB <- 0.2;
numSimulations <- 100
coverageProb.3 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.3) <- alphaRatioValues
colnames(coverageProb.3) <- betaValues
par(mfrow=c(6,6), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.4)
profileA <- alphaRatio*profileB + (alphaRatio*kB)*mBIntegrals - kA*mAIntegrals +
(beta - alphaRatio*beta)*hours + rnorm(n, mean=0, sd=0.4)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,2),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + mBIntegrals + mAIntegrals + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.3[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.3
alphaRatioValues <- seq(from=0, to=1, length.out=6)
betaValues <- seq(from=0, to=0.25, length.out=5)
hours <- seq(0, 36)
n <- length(hours) # Number of samples (time points)
r <- 4 # rank of design matrix
mA <- function(t) { return(sin(t)) }#return(sin(0.5*t)/(0.5*t)) }
mB <- function(t) { return(exp(-t)) }
mAIntegrals <- rep(0,n);  mBIntegrals <- rep(0,n)
for(i in 1:n) {
mAIntegrals[i] <- integrate(mA, lower=0, upper=hours[i])$value
mBIntegrals[i] <- integrate(mB, lower=0, upper=hours[i])$value
}
# Can adjust this parameter (mRNA degradation rate)
kA <- 0.2;  kB <- 0.2;
numSimulations <- 100
coverageProb.3 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.3) <- alphaRatioValues
colnames(coverageProb.3) <- betaValues
par(mfrow=c(6,5), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.4)
profileA <- alphaRatio*profileB + (alphaRatio*kB)*mBIntegrals - kA*mAIntegrals +
(beta - alphaRatio*beta)*hours + rnorm(n, mean=0, sd=0.4)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,2),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + mBIntegrals + mAIntegrals + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.3[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.3
alphaRatioValues <- seq(from=0, to=1, length.out=6)
betaValues <- seq(from=0, to=0.25, length.out=5)
hours <- seq(0, 36)
n <- length(hours) # Number of samples (time points)
r <- 4 # rank of design matrix
mA <- function(t) { return(sin(t)) }#return(sin(0.5*t)/(0.5*t)) }
mB <- function(t) { return(exp(-t)) }
mAIntegrals <- rep(0,n);  mBIntegrals <- rep(0,n)
for(i in 1:n) {
mAIntegrals[i] <- integrate(mA, lower=0, upper=hours[i])$value
mBIntegrals[i] <- integrate(mB, lower=0, upper=hours[i])$value
}
# Can adjust this parameter (mRNA degradation rate)
kA <- 0.2;  kB <- 0.2;
numSimulations <- 100
coverageProb.3 <- matrix(0, nrow=length(alphaRatioValues), ncol=length(betaValues))
rownames(coverageProb.3) <- alphaRatioValues
colnames(coverageProb.3) <- betaValues
par(mfrow=c(6,5), mai=c(0.2,0.2,0.2,0.2))
for(i in 1:length(alphaRatioValues)) {
alphaRatio <- alphaRatioValues[i]
for(j in 1:length(betaValues)) {
beta <- betaValues[j]
numSignificantResults <- 0
for(k in 1:numSimulations) {
# Generate n noisy points from mA and mB
profileB <- mB(hours) + rnorm(n, mean=0, sd=0.4)
profileA <- alphaRatio*profileB + (alphaRatio*kB)*mBIntegrals - kA*mAIntegrals +
(beta - alphaRatio*beta)*hours + rnorm(n, mean=0, sd=0.4)
# For a visual example, plot the first profileA and profileB
if(k == 1) {
plot(hours, profileA, type="o", pch=16, col="red", ylim=c(-2,2),
main=paste("A/B = ", alphaRatio, ", beta = ", beta, sep=""))
points(hours, profileB, type="o", pch=16, col="blue")
}
# Fit the model and use a t-test on slope instead of R^2
model_k <- lm(profileA ~ profileB + mBIntegrals + mAIntegrals + hours + 0)
R2 <- summary(model_k)$r.squared
FStat <- (R2/(r-1))/((1-R2)/(n-r))
pValue <- 1-pf(FStat, df1=r-1, df2=n-r)
# Increment counter if the p-value was < 0.05
numSignificantResults <- numSignificantResults + (pValue < 0.05)
}
coverageProb.3[i,j] <- numSignificantResults/numSimulations
}
}
coverageProb.3
setwd("~/Documents/Cornell University (PhD)/Research/Bayesian Gene Dynamics/Empirical Bayes Methods")
# Run the data loader script to read gene expression data and prior adjacency matrix
source("1_DatasetLoader.R")
# Load plotting functions
source("3_PlottingFunctions.R")
bayesLLR2Mat <- read.csv("LLR2 Matrices/BayesLLR2.csv", row.names=1)
bayesLLR2Mat.other <- read.csv("LLR2 Matrices/BayesLLR2_Other.csv", row.names=1)
bayesLLR2Mat.own <- read.csv("LLR2 Matrices/BayesLLR2_Own.csv", row.names=1)
colnames(bayesLLR2Mat) <- rownames(bayesLLR2Mat)
colnames(bayesLLR2Mat.other) <- rownames(bayesLLR2Mat.other)
colnames(bayesLLR2Mat.own) <- rownames(bayesLLR2Mat.own)
adjacencyBayes <- (bayesLLR2Mat > 0.9) + 0
networkBayes <- graph_from_adjacency_matrix(adjacencyBayes, mode='undirected', diag=F)
edgesBayes <- data.frame(as_edgelist(networkBayes))
colnames(edgesBayes) <- c("Gene1", "Gene2")
edgesBayes$Prior <- apply(edgesBayes, 1, function(x) priorMatrix[x[1], x[2]])
# Total number of edges
nrow(edgesBayes)
# Number of known, unknown, and unlikely edges, respectively
sum(edgesBayes$Prior == 1, na.rm=TRUE)
sum(is.na(edgesBayes$Prior))
sum(edgesBayes$Prior == 0, na.rm=TRUE)
# How many genes are in the largest connected component?
max(clusters(networkBayes, mode="strong")$csize)
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue' #alpha('blue', 0.2)
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3' #alpha('red', 0.2)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_nicely, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.35)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.35)
plot(networkBayes, layout=layout_with_sugiyama, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.35)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.35)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color=NA, edge.width=0.35)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkorange3", edge.width=0.35)
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue' #alpha('blue', 0.2)
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3' #alpha('red', 0.2)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkorange3", edge.width=0.35)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.35)
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue' #alpha('blue', 0.2)
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3' #alpha('red', 0.2)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_on_sphere, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_on_grid, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout.circle, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_as_tree, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_as_star, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_randomly, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout.star, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_as_bipartite, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue' #alpha('blue', 0.2)
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3' #alpha('red', 0.2)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue' #alpha('blue', 0.2)
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3' #alpha('red', 0.2)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
layout_
layout_()
plot(networkBayes, layout=layout.kamada.kawai, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_nicely, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray", edge.width=0.45)
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=3, vertex.frame.color="darkslategray")
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2, vertex.frame.color="darkslategray")
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color="darkslategray")
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkslategray",0.4))
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkslategray",0.5))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.color="goldenrod1", vertex.size=2.5, vertex.frame.color=alpha("lightsalmon4",0.5))
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.color="goldenrod1", vertex.size=2.5, vertex.frame.color=alpha("lightsalmon4",0.5))
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.color="goldenrod1", vertex.size=2.5, vertex.frame.color=alpha("black",0.5))
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("black",0.5))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("black",0.5))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("orange4",0.5))
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("navy",0.5))
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("navy",0.3))
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("navy",0.3))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
adjacencyNonBayes <- (nonBayesLLR2Mat > 0.9) + 0
networkNonBayes <- graph_from_adjacency_matrix(adjacencyNonBayes, mode='undirected', diag=F)
edgesNonBayes <- data.frame(as_edgelist(networkNonBayes))
colnames(edgesNonBayes) <- c("Gene1", "Gene2")
edgesNonBayes$Prior <- apply(edgesNonBayes, 1, function(x) priorMatrix[x[1], x[2]])
nonBayesLLR2Mat <- read.csv("LLR2 Matrices/NonBayesLLR2.csv", row.names=1)
nonBayesLLR2Mat.other <- read.csv("LLR2 Matrices/NonBayesLLR2_Other.csv", row.names=1)
nonBayesLLR2Mat.own <- read.csv("LLR2 Matrices/NonBayesLLR2_Own.csv", row.names=1)
colnames(nonBayesLLR2Mat) <- rownames(nonBayesLLR2Mat)
colnames(nonBayesLLR2Mat.other) <- rownames(nonBayesLLR2Mat.other)
colnames(nonBayesLLR2Mat.own) <- rownames(nonBayesLLR2Mat.own)
adjacencyNonBayes <- (nonBayesLLR2Mat > 0.9) + 0
networkNonBayes <- graph_from_adjacency_matrix(adjacencyNonBayes, mode='undirected', diag=F)
edgesNonBayes <- data.frame(as_edgelist(networkNonBayes))
colnames(edgesNonBayes) <- c("Gene1", "Gene2")
edgesNonBayes$Prior <- apply(edgesNonBayes, 1, function(x) priorMatrix[x[1], x[2]])
# Total number of edges
nrow(edgesNonBayes)
E(networkNonBayes)$color
pdf("NonBayesNetwork.pdf", height=4, width=4)
plot(networkNonBayes, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35), edge.width=0.2, edge.color=alpha('darkgray', 0.7))
title("Network of genes formed\n without prior information", cex.main=0.8, font.main=1)
dev.off()
pdf("NonBayesNetwork.pdf", height=4, width=4)
plot(networkNonBayes, vertex.label=NA, vertex.size=3, vertex.frame.color=alpha("darkblue",0.45), edge.width=0.2, edge.color=alpha('darkgray', 0.7))
title("Network of genes formed\n without prior information", cex.main=0.8, font.main=1)
dev.off()
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
plot(networkBayes, layout=layout_with_mds, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
plot(networkBayes, layout=layout_with_kk, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
title("Network of genes formed\n with prior information", cex.main=0.8, font.main=1)
dev.off()
E(networkBayes)$color[is.na(edgesBayes$Prior)] <- 'blue'
E(networkBayes)$color[!is.na(edgesBayes$Prior)] <- 'firebrick3'
E(networkBayes)$width[is.na(edgesBayes$Prior)] <- 0.6
E(networkBayes)$width[!is.na(edgesBayes$Prior)] <- 0.4
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
title("Network of genes formed\n with prior information", cex.main=0.6, font.main=1)
dev.off()
pdf("BayesNetwork.pdf", height=4, width=4)
plot(networkBayes, layout=layout_with_graphopt, vertex.label=NA, vertex.size=2.5, vertex.frame.color=alpha("darkblue",0.35))
title("Network of genes formed\n with prior information", cex.main=0.7, font.main=1)
dev.off()
pdf("NonBayesNetwork.pdf", height=4, width=4)
plot(networkNonBayes, vertex.label=NA, vertex.size=3, vertex.frame.color=alpha("darkblue",0.45), edge.width=0.2, edge.color=alpha('darkgray', 0.7))
title("Network of genes formed\n without prior information", cex.main=0.7, font.main=1)
dev.off()
# Total number of edges
nrow(edgesNonBayes)
# Number of known, unknown, and unlikely edges, respectively
sum(edgesBayes$Prior == 1, na.rm=TRUE)
sum(is.na(edgesBayes$Prior))
sum(edgesBayes$Prior == 0, na.rm=TRUE)
choose(1735,2)
choose(1735,2)/2
unique(edgesNonBayes$Gene1)
length(unique(edgesNonBayes$Gene1))
which(geneNames ! %in% unique(edgesNonBayes$Gene1))
which(! geneNames %in% unique(edgesNonBayes$Gene1))
geneNames[which(! geneNames %in% unique(edgesNonBayes$Gene1))]
unique(c(edgesNonBayes$Gene1, edgesNonBayes$Gene2))
length(unique(c(edgesNonBayes$Gene1, edgesNonBayes$Gene2)))
# How many genes are in the largest connected component?
max(clusters(networkNonBayes, mode="strong")$csize)
View(edgesNonBayes)
# Number of known, unknown, and unlikely edges, respectively
sum(edgesNonBayes$Prior == 1, na.rm=TRUE)
sum(is.na(edgesNonBayes$Prior))
sum(edgesNonBayes$Prior == 0, na.rm=TRUE)
# How many genes are in the largest connected component?
max(clusters(networkNonBayes, mode="strong")$csize)
clusters(networkNonBayes, mode="strong")
